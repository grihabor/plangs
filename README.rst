=============================
Языки программирования, 2017г
=============================

Лекция 1
========

Курс начал читаться в 1983 г. Роль ЯП в скиллах программиста падает (мнение
лектора может не совпадать с реальностью, авторский текст сохранен).
Первый ЯП высокого уровня - FORTRAN (formula translator, 1954-1957). FORTRAN
позволил избавиться от привязки программы к конкретной машине.

Что нужно знать программисту кроме C++?

+ Компилятор
+ Текстовый редактор
+ Отладчик
+ Стандартная библиотека

Дополнительные инструменты:

+ git, SVN
    Системы контроля версий
+ JIRA
    Система управления проектом (система контроля за проектом), подробнее - jira_
+ CI (Continuous Integration)
    практика разработки ПО, в которой члены команды проводят интеграцию не реже чем раз в день. Результаты
    интеграции проверяются автоматически, обычно используя автотесты и
    статический анализ кода.
+ SCRUM
    спринты (демонстрация работы команды) каждые 1-2 недели,
    подробнее - scrum_

.. _jira: https://ru.atlassian.com/software/jira
.. _scrum: https://ru.atlassian.com/agile/scrum

Парадигмы программирования
--------------------------

1. Императивная (Фон-Неймановская)
2. Функциональная
3. Логическая
4. ООП

Императивная парадигма
''''''''''''''''''''''

Принципы Фон-Неймана

+ Память - линейная, однородная
+ Состояние (программы?) определяется памятью
S1 → S2
: Оператор меняет состояние, операция вычисляет выражение
Языки высокого уровня структурируют данные и вводят операции над ними.
Основной оператор в это парадигме - присваивание ( := )
В языке ассемблера mov -- классическая и самая основная инструкция присваивания.
Кроме присваивания существует еще некоторый набор операций.

Функциональная парадигма (я слаб в ней, чекните)
'''''''''''''''''''''''''''''''''''''''''''''''

Основа -- вычисление функций -- f(a, b) .
У них (функций?) нет состояний.
Доказывать свойство программы просто
Q .. .. , где - предикат входных данных и предикат результата. (?) 1 ⇐ . ⇐ P ⇐ . ⇐ Q2 Q1
, Q2
Подробнее - wikibooks, еще источник
FP​ - первый функциональный ЯП (ну хоть его мы не учим)
Фон-Неймановские (императивные) программы тяжело распараллеливать (возможно,
ФП - легко, не уверен)

Логическое программирование
'''''''''''''''''''''''''''

`Математическая логика и логическое программирование`_

.. _Математическая логика и логическое программирование:: http://mk.cs.msu.ru/index.php/%D0%9C%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0_%D0%B8_%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(3-%D0%B9_%D0%BF%D0%BE%D1%82%D0%BE%D0%BA)

ООП
'''

ООП - объектно-ориентированное программирование, это надстройка над (1) -
Императивной парадигмой. (содержательно, согласен)
Основа ООП - объект.
Объект - экземпляр некоторого класса.
У объекта скрыта внутренняя реализация (черный ящик, сокрытие деталей).
Он может посылать сообщения другим объектам и определенным образом
реагировать на сообщения сам.
Больше - в wiki.

Лекция 2
========

Парадигма программирования =/ Язык программирования
Деятельность программирования (делится на 3 части):

#. Игровое программирование
    прогр-е для себя. В ЯП главное, чтобы
программисту нравилось (?). Пример - BASIC​ (???)

#. “Научное” программирование 
    прогр-е для себя и узкого круга коллег. Главное -
результат. Пример ЯП - Perl​ (изначально создан для этого, потом стал
промышленным). Средства - sed, awk (ну так сюда хоть bash пихай, хз зачем
это тут)

#. Индустриальное программирование  

    написание программ для последующего их
использования в отрыве от программиста.
ТП - технологическая потребность
КТП - критическая ТП
Модульность - это КТП для ЯП здесь.
Пример - FORTRAN​.
Всякие разные ЯПы:
PL/1​ (IBM), Algol 68​ (на его основе был создан С​ (но это не точно)), Pascal​.
Ada​ - был признан военным стандартом. ЯП для систем реального времени (в боевых
действиях). Требования - надежность, устойчивость (к отказам), ...
Modula-2​ - был нацелен на системное ПО; сейчас в эту нишу занял С.
GNAT ​- GNU NYU Ada Translator
Курс изначально был основан на языке Ada.

Основные выводы
---------------

ЯП не внедряются, а выживают. Предсказать это нельзя. Выживают, как правило, те
ЯП, которые придумывает один человек.
Язык должен быть достаточно прост (при обучении первые программы должны
появляться на 1-2 день)
Нет и не будет никогда единого ЯП.
Задача для индустриального ЯП:
<stdin> => [reverse] => <stdout>.
C:
<прога, которая реверсит stdin, не благодарите>
Недостаток этой программы - статическое распределение памяти, писать не очень
удобно.

Лекция 3
========

Беда использования realloc() - фрагментация памяти.
Работа с динамической памятью - тонкая вещь.
Modula-2​ -> Oberon ​- 10 стр. описание языка (?).
ЯП был нацелен на системное программирование (СП). Первый СП-ЯП со сборкой
мусора. Компилятор ЯП Oberon на Oberon - 4k строк.

Принципы выбора функциональности ЯП:

+ Принцип сундука - берем все, что нужно (что может понадобиться)
+ Принцип <...> - берем все, без чего ЯП (наверное) не имеет смысла.
Go​ - язык с динамической сборкой мусора.
Объявления в Go: var <name> <type> [ = <value> ]
Можно иначе, без явного указания типа <name> :=​ <value>

Вспомним задачу <stdin> => [reverse] => <stdout>.
Решение на Go:

.. code-block:: go
    import {
        “put”,
        “OS”,
        “io/ioutil”,
        “string"
    }
    func main() {
        rdr := os.stdin // объявление переменной rdr
        b, err := ioutil.ReadAll(rdr) //b - массив байт, ReadAll()
        // возвращает кортеж
        if err != nil {
            panic (“Bad Input”)
        }
        b := string(b)
        // альтернатива - s := string.Split(b, “”), “” - пустая
строка
        // в s будет срез (slice) массива
        for (i:= len(b)-1; i>=0; --i {
            fmt.print(b[i]) // могут быть проблемы с кодировками
         }
    }
    
Решение на C#​:

.. code-block:: c#


Решение на Python​:

.. code-block:: python

    import sys
    print(sys.stdin.read()[::-1])
    
Лекция 4
========

Язык С++
--------

generic (обобщенное) программирование - шаблоны (параметрический полиморфизм)
в Python​, JS​ его нет и быть не может
Решение задачи на C++:

.. code-block:: c++

    #include <algorithm>
    #include <vector>
    #include <iostream>
    #include <iterator>
    
    using namespace std;
    
    int main()
    {
        vector<char> v;
        copy (istream_iterator<char>(cin), istream_iterator<char>(),
back_inserter(v));
        copy (v.rbegin(), v.rend(), ostream_iterator<char>(cout));
        return 0;
    }
    
Функциональное программирование
-------------------------------

Точка рассмотрения ЯП:

+-------------------------------------------------+
|                      Базис                      |
+------------------------+------------------------+
| Скалярный базис        | Структурный базис      |
+------------------------+------------------------+
| Встроенные типы        | Составные типы данных, |
| и операции, операторы, | массивы, структуры,    |
| выражения              | составные операторы    |
+------------------------+------------------------+

LISP​ ( “Чистый” LISP). LISP​ - List Processing.
(LISP не знаю, переписываю с лекций, чекните & поправьте если что)
У LISP ​Крайне простой базис (правила).
Базис LISP’a​:
Типы данных: (атом) -> (символ, т.е. идентификатор ) | (целое число)
Средство развития: (S - выражение) -> (голова)(хвост)
Шаг вычисления: число вычисляется само в себя.
Список - частный случай S-выражения
Иллюстрации:
(something).nil - список
() или nil - пустой список
(a.(b.(c.nil))) ~ (a b c) - средство облегчения нотации.
( (1 a) (2) 3 b ) - тоже список
Замечание: вообще правильнее рисовать так: